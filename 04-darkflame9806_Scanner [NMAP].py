### Dependencias Kali Linux: Programa darkflame9806-scanner NMAP en Python ###
# Nota: partimos de una instalación limpia sin herramientas preinstaladas

# $ sudo apt -y install python3
# $ sudo apt -y install python3-pip
# $ pip install python-nmap

print("""
                                           ...',;;;;:::;;;,'...                                     
                                      ..,;clodddddddddddddddddlc:;,..                               
                                   .,:ldddddddddddddddddddddddddddddol:;,..                         
                                .':oddddddddddddddddddddddddddddddddddddddoc;'.                     
                               'cdddddddddddddddddddddddddddddddddddddddddddddoc,.                  
                             .:odddddddddddddddddddddddddddddddddddddddddddddddddo:.                
                            'lddddddddddddddddddddddddddddddddddddddddddddddddddddddc,.             
                           ,odddddddddddddddddddddddddddddddddddddddddddddddddddddddddl;.           
                          ,oddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddo;.         
                        .;ddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddo:.       
                       .cdddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddo;.     
                     ':oddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddc.    
                  .;lddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddc.   
                 .cdddddoc:::clddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddd:.  
                 ;ddddo;.     .,ldddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddd,  
                 :dddl.         .lddddddddddddddddoooodddddddddddddddddddddddddddddddddddddddddddc. 
                .:ddo'           .lddddddddddddo:'....';lddddddddddddddddddddddddddddddddddddddddo' 
                .ldd:             'oddddddddddl.         .:odddddddddddddddddddddddddddddddddddddo, 
                ,ddo'             .:xddddddddl.            .;ldddddddddddddddddddddddddddddddddddd, 
               .lddc.             .:ddddddddo,               .;ldddddddddddddddddddddddddddddddddd, 
              .cddd,             .;oddddddddl.                 .;odddddddddddddddddddddddddddddddd, 
             .cdddc.         ..,:ldddddddddx:.                   'ldddddddddddddddddddddddddddddxo. 
            .cdddc.      ..;cloddddddddddddd:                     'ldddddddddddddddddddddddddddddc. 
           .:ddxl.     .:lddxddddddllddddddd:.                    .:ddddddddddddddddddddddddddddd;  
           'odddo;..';ldddddddddoc'..;ddddddl.                     ;ddddddddddddddddddddddddddddl.  
           .ldddddddddddddddddo:.    'odddddo'                     :dddddddddddddddddddddddddddd,   
            .:ddddddddddddddoc.      .lxddddd:                    .cddddddddddddddddddddddddddd:.   
              'cdddddddddddc'        .:xdddddl.                   'oddddddddddddddddddddddddddc.    
               .:ddddddddo,.          ,odddddd;                  .cddddddddddddddddddddddddddc.     
                .oxdddddl'            .lddddddo,.               .lddddddddddddddddddddddddddc.      
                .cdddddd:.            .:ddddddddc,'.         ..:odddddddddddddddddddddddddd:.       
                .lddddddo:,,,;,.       ;dddddddddddoc:,,'',,:ldddddddddddddddddddddddddddo,         
                'oddddddddddxdd;       ;dddddddddddddddddddddddddddddddddddddddddddddddo:.          
               .:ddddddddddddddo,     .lddddddddddddddddddddddddddddddddddddddddddddddc.            
               'odddddddddddddddoc;;:coddddddddddddddddddoodddddddddl:;,,:lddddddddl:.              
               :dddddddddddddddddddddddddddddddddddddddo;...,lddddd:.     .:oddoc:'.                
              .,;,',coddddddddddddddddddddddddddddddddd;     .ldddl.        .'..                    
                     ;odddddddddddddddddddddddddddddddo.      'odd:.                                
                     .cdddddddddddddddddddddddddddddddl.      .ldd:                                 
                      ;dddddoc::coddddddddddo:;,:oddddc.      .ldd:                                 
                      'oddd:.    .,ldddddddc.    'codd:       .oxd,                                 
                      'odd:.       .:dddddo.     .'cdo'       .;c;.                                 
                      ,ddc.         .:dddd:        .,'                                              
                      ;xo,           'oddd,                                                         
                      'c;.           .lddo'                                                         
                                     .cxdo'                                                         
                                     .cddo,                                                         
                                     .lddd;                                                         
                                     'oddd:                                                         
                                     ;dddx:.                                                        
                                    .cdddx:.                                                        
                                    .ldddd:                                                         
                                    .ldddo'                                                         
                                    .cddo;.                                                         
                                     .''.                                                           
                                                                                                    
""")

print("""
-------------|     _            _     __ _                       ___   ___   ___   __   |-------------
-------------|  __| | __ _ _ __| | __/ _| | __ _ _ __ ___   ___ / _ \ ( _ ) / _ \ / /_  |-------------
-------------| / _` |/ _` | '__| |/ / |_| |/ _` | '_ ` _ \ / _ \ (_) |/ _ \| | | | '_ \ |-------------
-------------|| (_| | (_| | |  |   <|  _| | (_| | | | | | |  __/\__, | (_) | |_| | (_) ||-------------
-------------| \__,_|\__,_|_|  |_|\_\_| |_|\__,_|_| |_| |_|\___|  /_/ \___/ \___/ \___/ |-------------
-------------|                                                                          |-------------
""")

print("[Info] Herramienta para escaneo de puertos abiertos en una dirección IP")
print("  ||   ### Gómez Hernández Sinuhé Alejandro ###")
print("  ||   Inclusiones:")
print("  ||   * Estado del host")
print("  ||   * Dirección MAC y proveedor")
print("  ||   * Puertos abiertos")
print("  ||   * Protocolos habilitados")
print("  ||   * S.O. del Host objetivo")

import nmap

print("-----------------------------------------------------------------")
def validar_ip(): # Función para verificar que la IP ingresada sea válida.
    while(True):
        ip = input("\n[☠] Introduce la IP objetivo: ")
        octetos = ip.split(".") # Se divide en octetos la IP (array).
        if len(octetos) != 4: # Revisa que existan 4 octetos.
            print("Ingresa una IP completa")
            continue
        try: # Intentamos convertir todos los octetos a enteros.
            octeto1 = int(octetos[0]) # El octeto 1 debe encontrarse en un rango de 0 a 223 (correspondiente a una red máximo clase C)
            octeto2 = int(octetos[1]) # Los octetos 2 a 4 deben encontrarse en un rango de 0 a 254
            octeto3 = int(octetos[2])
            octeto4 = int(octetos[3])
            if octeto1 in range(1,224) and octeto2 in range(0,255) and octeto3 in range(0,255) and octeto4 in range(0,255): # Valida el rango de cada octeto.
                break
            else:
                print("Solo se aceptan números enteros, intentalo de nuevo.")
        except ValueError:
            print("Algo ha salido mal, intentalo de nuevo.")
    return ip
host = validar_ip()

nm = nmap.PortScanner() # Generamos una instancia de la herramienta de nmap.PortScanner
puertos_abiertos = "-p" # Aquí acumularemos los puertos que se encuentren abiertos.
count = 0
results  = nm.scan(host, arguments="-sS -PU -PA -sV -O --osscan-guess") # No pueden modificarse los argumentos del escaneo (glosario de argumentos al final del código*)

print("\n-----------------------------------------------------------------")
print("\n[☠] Host : %s" % host)
print("\n[☠] Estado : %s" % nm[host].state()) # Con la función .state() obtenemos el estado del host.

# Usamos la función items() para obtener la tupla con diccionarios con la información del objetivo y la convertimos en un arreglo de diccionarios con la función .list()
items= nm[host].items()
lista_items=list(items)

print("\n-----------------------------------------------------------------")
# Obtenemos la MAC-Address
try:
    for lista in lista_items: # Secorremos la lista
        if isinstance(lista[1],dict): # Buscamos si el segundo elemento en cada lista es un diccionario
            if "mac" in lista[1]: # Buscamos si existe alguna clave llamada "mac"
                mac_address = lista[1]["mac"] # Si encontramos la clave, guardamos el valor en una variable
except:
    print("No se ha encontrado información acerca de la dirección MAC")
# Nuestra llave dentro del diccionario será la MAC-Address
try:
    for lista in lista_items: # Recorremos cada lista / diccionario
        if isinstance(lista[1],dict): # Comprobamos si cada segundo elemento es un diccionario
            if mac_address in lista[1]: # Comprobamos si el valor de la llave se encuentra ahí
                vendor = lista[1][mac_address] # Sí es así, guarda el valor en una variable
                break
            else:
                continue
        else:
            continue
    print("\n[☠] MAC-Address: %s" % (mac_address))
    print("\n[☠] Proveedor: %s" % (vendor))
except:
    print("\n[☠] No se ha encontrado información acerca de la dirección MAC o proveedor.")

print("\n-----------------------------------------------------------------")
# VERSION DE S.O.
# Con los argumentos de búsqueda, independientemente de si existe un valor o no, siempre será la misma ruta para dichas claves
try:
    print("\n[☠] Sistema Operativo: %s" % (lista_items[7][1][0]["name"]))
    print("\n[☠] Tipo: %s" % (lista_items[7][1][0]["osclass"][0]["type"]))
    print("\n[☠] Familia: %s" % (lista_items[7][1][0]["osclass"][0]["osfamily"]))
    print("\n[☠] Generación: %s" % (lista_items[7][1][0]["osclass"][0]["osgen"]))
    print("\n[☠] cpe: %s" % (lista_items[7][1][0]["osclass"][0]["cpe"]))
except:
    print("\n[☠] No se ha encontrado información acerca del S.O.")

print("\n-----------------------------------------------------------------")
# SERVICIOS
tcp = lista_items[5][1] # Extraemos la tupla que contiene el diccionario correspondiente al protocolo TCP
try:
    for puerto in range(1,65000): # Comprobamos todo el rango de puertos en busca de coincidencias
        if puerto in tcp:
            print("\n[☠] Puerto: %s" % (puerto))
            print("[☠] Estado: %s" % (tcp[puerto]["state"]))
            print("[☠] Protocolo: %s" % (tcp[puerto]["name"]))
            print("[☠] Servicio: %s" % (tcp[puerto]["product"]))
            print("[☠] Versión: %s" % (tcp[puerto]["version"]))
            print("[☠] Info Extra: %s" % (tcp[puerto]["extrainfo"]))
            print("[☠] cpe: %s" % (tcp[puerto]["cpe"]))
        else:
            continue
except:
    print("\n[☠] No se ha encontrado información acerca de servicios o algo ha salido mal.")
print("\n-----------------------------------------------------------------")
# PUERTOS ABIERTOS
for protocolo in nm[host].all_protocols():
    lport = nm[host][protocolo].keys()
    sorted(lport)
    for puerto in lport:
        if count == 0:
            puertos_abiertos = puertos_abiertos+" "+str(puerto)
            count = 1
        else:
            puertos_abiertos = puertos_abiertos+" "+str(puerto)

print("\n[☠] Puertos abiertos:"+puertos_abiertos+" "+str(host))

print("\n-----------------------------------------------------------------")

"""
ARGUMENTOS NMAP:
-sS: utiliza TCP SYN enviando un paquete TCP con la bandera SYN activada al dispositivo o servidor que está escaneando.
Si el puerto de destino está abierto, el servidor responderá con un paquete TCP-ACK o TCP-RST si está cerrado.
Permite escanear miles de puertos por segundo, y al no llegar a completar las conexiones TCP no llama la atención.

-PU: ping UDP

-PA: ping TCP ACK

-sV: detección de la versión de servicios

-O: activar la detección del Sistema Operativo

--osscan-guess: nmap intentará "adivinar" el S.O. del dispositivo basandose en respuestas a solicitudes de red.
"""